/**
 *
 * {{ properCase name }}
 *
 */

import {connect} from 'react-redux';
import PropTypes from 'prop-types';
import React, {Component} from 'react';
import {bindActionCreators} from 'redux';
import * as {{properCase actionName}} from "../../actionCreators/{{actionName}}";

/**
 * Component Lifecycle
 * Mounting - These methods are called when an instance of a component is being created and inserted into the DOM
 *   constructor(props)
 *   componentWillMount()
 *   render()
 *   componentDidMount()
 * Updating - An update can be caused by changes to props or state.
 *   componentWillReceiveProps()
 *   shouldComponentUpdate()
 *   componentWillUpdate()
 *   render()
 *   componentDidUpdate(prevProps, prevState)
 * Unmounting - This method is called when a component is being removed from the DOM
 *   componentWillUnmount()
 */
export class {{ properCase name }} extends Component {

    /**
     * The constructor for a React component is called before it is mounted. When implementing the constructor for a
     * React.Component subclass, you should call super(props) before any other statement. Otherwise, this.props will
     * be undefined in the constructor, which can lead to bugs. The constructor is the right place to initialize state.
     * If you don't initialize state and you don't bind methods, you don't need to implement a constructor for your
     * React component. It's okay to initialize state based on props. This effectively "forks" the props and sets the
     * state with the initial props.
     */
    constructor(props) {
        super(props);
        this.displayName = 'containers/{{ name }}';
        this.state = {};
        /**
          * Using State Correctly:
          * 1.) Do Not Modify State Directly ( except in the constructor )
          * 2.) State Updates May Be Asynchronous
          *     eg // Correct way...
          *          this.setState((prevState, props) => ({
          *              counter: prevState.counter + props.increment
          *          }));
          * 3.) State Updates are Merged
          *     eg // Correct way..
          *        constructor(props) {
          *            super(props);
          *            this.state = { posts: [], comments: [] };
          *        }
          *        componentDidMount() {
          *            fetchPosts().then(response => {
          *            this.setState({ posts: response.posts });
          *        });
          *        fetchComments().then(response => {
          *            this.setState({ comments: response.comments });
          *        });
          * 4. The Data Flows Down - Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn't care whether it is defined as a function or a class.
          */
        // bind the functions to this class without using the :: ( which creates unnecessary excessive scope )
        // this.<function> = this.<function>.bind(this);
    }
    /**
     * is invoked immediately before mounting occurs. It is called before render(), therefore setting state
     * synchronously in this method will not trigger a re-rendering. Avoid introducing any side-effects or
     * subscriptions in this method.
     */
    componentWillMount() {}
    /**
     * is invoked immediately after a component is mounted. Initialization that requires DOM nodes should go here.
     * If you need to load data from a remote endpoint, this is a good place to instantiate the network request.
     * Setting state in this method will trigger a re-rendering.
     */
    componentDidMount() {}
    /**
     * is invoked before a mounted component receives new props. If you need to update the state in response to prop
     * changes (for example, to reset it), you may compare this.props and nextProps and perform state transitions
     * using this.setState() in this method. Note that React may call this method even if the props have not changed,
     * so make sure to compare the current and next values if you only want to handle changes. This may occur when
     * the parent component causes your component to re-render. React doesn't call componentWillReceiveProps with
     * initial props during mounting. It only calls this method if some of component's props may update. Calling
     * this.setState generally doesn't trigger componentWillReceiveProps.
     */
    componentWillReceiveProps() {}
    /**
     * to let React know if a component's output is not affected by the current change in state or props. The default
     * behavior is to re-render on every state change, and in the vast majority of cases you should rely on the
     * default behavior. shouldComponentUpdate() is invoked before rendering when new props or state are being
     * received. Defaults to true. This method is not called for the initial render or when forceUpdate() is used.
     * Returning false does not prevent child components from re-rendering when their state changes. Currently,
     * if shouldComponentUpdate() returns false, then componentWillUpdate(), render(), and componentDidUpdate()
     * will not be invoked. Note that in the future React may treat shouldComponentUpdate() as a hint rather
     * than a strict directive, and returning false may still result in a re-rendering of the component. If you
     * determine a specific component is slow after profiling, you may change it to inherit from React.PureComponent
     * which implements shouldComponentUpdate() with a shallow prop and state comparison. If you are confident you
     * want to write it by hand, you may compare this.props with nextProps and this.state with nextState and return
     * false to tell React the update can be skipped.
     */
    shouldComponentUpdate() {}
    /**
     * Is invoked immediately before rendering when new props or state are being received. Use this as an opportunity
     * to perform preparation before an update occurs. This method is not called for the initial render. Note that
     * you cannot call this.setState() here. If you need to update state in response to a prop change,
     * use componentWillReceiveProps() instead.
     */
    componentWillUpdate() {}
    /**
     *  is invoked immediately after updating occurs. This method is not called for the initial render. Use this as
     *  an opportunity to operate on the DOM when the component has been updated. This is also a good place to do
     *  network requests as long as you compare the current props to previous props (e.g. a network request may not
     *  be necessary if the props have not changed).
     */
    componentDidUpdate(prevProps, prevState) {}
    /**
     * Invoked immediately before a component is unmounted and destroyed. Perform any necessary cleanup in this
     * method, such as invalidating timers, canceling network requests, or cleaning up any DOM elements that were
     * created in componentDidMount
     */
    componentWillUnmount() {}
    /**
     * Render should examine this.props and this.state and return a single React element. This element can be either
     * a representation of a native DOM component, such as <div />, or another composite component that you've
     * defined yourself. You can also return null or false to indicate that you don't want anything rendered. When
     * returning null or false, ReactDOM.findDOMNode(this) will return null. The render() function should be pure,
     * meaning that it does not modify component state, it returns the same result each time it's invoked, and it
     * does not directly interact with the browser. If you need to interact with the browser, perform your work
     * in componentDidMount() or the other lifecycle methods instead. Keeping render() pure makes components
     * easier to think about.
     */
    render() { return ( <div> </div> ); }
}

{{ properCase name }}.propTypes = {
    // You can declare that a prop is a specific JS primitive. By default, these
    // are all optional.
    optionalArray: PropTypes.array,
    optionalBool: PropTypes.bool,
    optionalFunc: PropTypes.func,
    optionalNumber: PropTypes.number,
    optionalObject: PropTypes.object,
    optionalString: PropTypes.string,
    optionalSymbol: PropTypes.symbol,
    // Anything that can be rendered: numbers, strings, elements or an array
    // (or fragment) containing these types.
    optionalNode: PropTypes.node,
    // A React element.
    optionalElement: PropTypes.element,
    // You can also declare that a prop is an instance of a class. This uses
    // JS's instanceof operator.
    optionalMessage: PropTypes.instanceOf(Message),
    // You can ensure that your prop is limited to specific values by treating
    // it as an enum.
    optionalEnum: PropTypes.oneOf(['News', 'Photos']),
    // An object that could be one of many types
    optionalUnion: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.number,
        PropTypes.instanceOf(Message)
    ]),

    // An array of a certain type
    optionalArrayOf: PropTypes.arrayOf(PropTypes.number),
    // An object with property values of a certain type
    optionalObjectOf: PropTypes.objectOf(PropTypes.number),
    // An object taking on a particular shape
    optionalObjectWithShape: PropTypes.shape({
        color: PropTypes.string,
        fontSize: PropTypes.number
    }),
    // You can chain any of the above with `isRequired` to make sure a warning
    // is shown if the prop isn't provided.
    requiredFunc: PropTypes.func.isRequired,
    // A value of any data type
    requiredAny: PropTypes.any.isRequired,
    // You can also specify a custom validator. It should return an Error
    // object if the validation fails. Don't `console.warn` or throw, as this
    // won't work inside `oneOfType`.
    customProp: function(props, propName, componentName) {
        if (!/matchme/.test(props[propName])) {
            return new Error(
                'Invalid prop `' + propName + '` supplied to' +
                ' `' + componentName + '`. Validation failed.'
            );
        }
    },
    // You can also supply a custom validator to `arrayOf` and `objectOf`.
    // It should return an Error object if the validation fails. The validator
    // will be called for each key in the array or object. The first two
    // arguments of the validator are the array or object itself, and the
    // current item's key.
    customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {
        if (!/matchme/.test(propValue[key])) {
            return new Error(
                'Invalid prop `' + propFullName + '` supplied to' +
                ' `' + componentName + '`. Validation failed.'
            );
        }
    })
};

/**
 *  If this argument is specified, the new component will subscribe to Redux store updates.
 *  This means that any time the store is updated, mapStateToProps will be called. The
 *  results of mapStateToProps must be a plain object*, which will be merged into the
 *  component’s props. If you don't want to subscribe to store updates, pass null or
 *  undefined in place of mapStateToProps. If ownProps is specified as a second argument,
 *  its value will be the props passed to your component, and mapStateToProps will be
 *  additionally re-invoked whenever the component receives new props (e.g. if props
 *  received from a parent component have shallowly changed, and you use the ownProps
 *  argument, mapStateToProps is re-evaluated).
 *
 * @param state
 * @param [ownProps]
 * @returns
 */
let mapStateToProps = (state, ownProps = {}) => {
    return {
        {{ reducerProperty }}: state.{{ reducer }}.{{ reducerProperty }}
    };
};

/**
 * If an object is passed, each function inside it is assumed to be a Redux action creator.
 * An object with the same function names, but with every action creator wrapped into a
 * dispatch call so they may be invoked directly, will be merged into the component’s props.
 * If a function is passed, it will be given dispatch. If you don't want to subscribe to
 * store updates, pass null or undefined in place of mapStateToProps. It’s up to you to
 * return an object that somehow uses dispatch to bind action creators in your own way.
 * (Tip: you may use the bindActionCreators() helper from Redux.) If you omit it, the default
 * implementation just injects dispatch into your component’s props. If ownProps is
 * specified as a second argument, its value will be the props passed to your component,
 * and mapDispatchToProps will be re-invoked whenever the component receives new props.
 *
 * @param dispatch
 * @param [ownProps]
 * @returns
 */
let mapDispatchToProps = (dispatch, ownProps = {} ) => {
    return {
        {{actionName}}ActionDispatcher: bindActionCreators({{properCase actionName}}, dispatch)
    };
};

export default connect(mapStateToProps, mapDispatchToProps)( {{ properCase name }} );
